%!TEX root = ../surface_reconstruction.tex


\section{Описание последовательно алгоритма}
Здесь будет описание последовательного алгоритма  

Пусть точки $p_i \in R^{3}, i \in \{1, . . . , N\}$, взяты с
поверхности S (возможно, с шумом измерения). Цель состоит в том, чтобы спроецировать точку $r \in R3$ вблизи S на двумерную поверхность SP, аппроксимирующую $p_i$. Процедура MLS мотивирована дифференциальной геометрией, а именно тем, что поверхность может быть локально аппроксимирована функцией.

Эталонная плоскость: 
Найдите локальный эталонный домен (плоскость) для r (см. рис.). Локальная плоскость $ H = \{x \mid \langle n, x \rangle - D = 0, x  \in R^{3}\}, n \in R^{3},  \parallel n \parallel = 1 $ вычисляется так, чтобы минимизировать локальную взвешенную сумму квадратов расстояний точек pi до самолет. Веса, прикрепленные к pi, определяются как функция расстояния от pi до проекции r на плоскость H, а не от расстояния до r. Предположим, что q является проекцией r на H, тогда H находится путем локальной минимизации

\includegraphics[scale=0.4]{0.png}


\section{Существующие алгоритмы}
\subsection{Оператор локально-оптимальной проекции(LOP)}
Происхождением метода является алгоритм Вайсфельда для решения задачи Ферма-Вебера о расположении точек, также известный как многомерная медиана L1. Это статистический инструмент, который традиционно применяется во всем мире для многомерных непараметрических точечных выборок, чтобы получить хороший представитель для большого количества выборок при наличии шума и выбросов. Проблема была впервые известна как проблема оптимального местоположения Вебера ~\cite{WEBER}. Задача состояла в том, чтобы найти оптимальное место для промплощадки, минимизирующее стоимость доступа. В статистике проблема известна как медиана L1 ~\cite{BROWN, SMALL}.

Задача Ферма-Вебера (глобальная) о расположении точек рассматривается как пространственная медиана, поскольку, будучи ограничена одномерным случаем, она совпадает с одномерной медианой и наследует некоторые ее свойства в многомерной постановке.

Реконструкция с помощью оператора проекции имеет важное достоинство: она определяет непротиворечивую геометрию на основе точек данных и предоставляет конструктивные средства для повышения ее дискретизации. 
Оператор локально-оптимальной проекции без параметризации использует более примитивный механизм проецирования, но поскольку он не основан на локальной 2D-параметризации, он более надежен и хорошо работает в сложных сценариях. Кроме того, если точки данных взяты локально с гладкой поверхности, оператор обеспечивает аппроксимацию второго порядка, что приводит к правдоподобной аппроксимации выбранной поверхности.

Оператор LOP имеет две непосредственные функции: во-первых, его можно использовать в качестве этапа предварительной обработки для любого другого метода реконструкции более высокого порядка (например, RBF). LOP можно применять к необработанным отсканированным данным для создания чистого набора данных, в качестве средства эффективного уменьшения шума и выбросов, а также для упрощения определения ориентации и топологии локальной поверхности. Во-вторых, его можно использовать для уточнения данного набора данных.

Для множества точек данных $P = \{p_j\}_{j\in J} \subset \mathbf R^{3}$, LOP проецирует произвольное множество точек $X^{(0)} = \{x_i^{(0)} \} _{i \in I} \subset \mathbf R^{3}$ на множество $P$, где $I$, $J$ обозначают наборы индексов. Множество спроецированных точек $Q = \{q_i\}_{i\in I}$ определяется так, чтобы оно минимизировало сумму взвешенных расстояний до точек P относительно радиальных весов с центром в том же множестве точек Q. Кроме того, точки Q не должны быть слишком близко друг к другу. Эта структура индуцирует определение искомых точек Q как решение уравнения с фиксированной точкой 
$$Q = G(Q),$$
где
$$G(C) = argmin_{X = \{x_i\}_{i \in I}} \{E_1(X,P,C) + E_2(X,C)\},$$
$$E_1(X,P,C) = \sum_{i \in I} \sum_{j \in J}\parallel x_i - p_j \parallel \theta(\parallel c_i - p_j \parallel), $$ 
$$E_2(X, C) = \sum _{i^{'} \in I} \lambda_{i^{'}}\sum_{i \in I \setminus\{i^{'}\}} \eta(\parallel x_{i^{'}}- c_i  \parallel)\theta(\parallel c_{i^{'}} - c_i \parallel)$$

Здесь $\theta(r)$ — быстро убывающая гладкая весовая функция с компактным опорным радиусом $h$, определяющая размер радиуса влияния, $\eta(r)$ — другая убывающая функция, штрафующая $x_{i^{'}}$ за то, что они подходят слишком близко к другим точкам, и $\{\lambda_i\}_{i \in I}$ являются уравновешивающими членами, которые обозначены через $\mathbf \land$. В двух словах, термин $E_1$ заставляет спроецированные точки $Q$ аппроксимировать геометрию $P$, а член $E_2$ стремится  сохранить справедливое распределение точек $Q$. Правильные значения $\mathbf\land$ могут гарантировать степень аппроксимации второго порядка оператора LOP при условии, что данные отбираются с поверхности $C^{2}$.


\section{Параллелизм}

Процедура определения поверхности методом наименьших квадратов была представлена Левином ~\cite{LEVIN}. Параллельный вариант, модифицированного алгоритма MLS с использованием MPI, описан в алгоритме 1. Алгоритм предполагает что облако точек равномерно распределено по всем процессам. Поэтому часть P, доступная локально в процессе u, обозначается через $P^{(u)}$. Через $P_l^{u}$, $P_r^{u}$ обозначены левая и правая граница частей облака точек. Они последовательно получаются от соседних процессов обменами по топологии кольцо. Дополнительных коммуникаций не требуется, а остальные вычисления выполняются локально. В цикле по локальному облаку точек $P^{(u)}$ выполняется процедура проецирования MLS: сначала создается локальная эталонная плоскость H для точки $p_j$. Проекция $p_j$ на H определяет начало координат q. Затем вычисляется локальная полиномиальная аппроксимация g высот $f_j$ точек $p_j$ над H. В обоих случаях вес для каждого из $p_j$ является функцией расстояния до q. Проекция $p_j$ на g является результатом процедуры проецирования MLS. \\*
\textbf{Algorithm 1}  Parallel moving least squares with MPI \\*
\textbf{Input:} a data set of points $P = \{p_i\}$ $i = 1..n$ \\*
\textbf{Output:} a smooth surface SP (MLS surface) based on the input
points \\*
1: \textbf{for each} process u \textbf{do} \\*
2: \quad $P^{(u)} = read(P)$ // each process reads its part of point cloud $P^{(u)} = \{p_j\}$ $j = 1..m$ \\*
3: \quad $P\_l^{(u)} = send\_recv(P\_r^{(u-1)})$ // getting the left border\\* 
4: \quad $P\_r^{(u)} = send\_recv(P\_l^{(u+1)})$ // getting the right border\\*
5: \quad\textbf{for each} point $j = 1..m $ \textbf{do}\\*
6: \quad\quad$H = generate\_plane(p_j)$ \\*
7: \quad\quad$g = generate\_local\_polynomial\_approximation(H)$ \\*
8: \quad\quad$result\_point = project\_on\_polynom(p_j, polynom)$ \\*
9: \quad\textbf{end for} \\*




Параллельный алгоритм

\includegraphics[scale=0.5]{1.png}

\section{Результаты экспериментов}

Время работы на n процессах n = 1...8


\includegraphics[scale=0.4]{T(P).png}

Ускорение:

\includegraphics[scale=0.4]{S(P).png}

Эффективность:

\includegraphics[scale=0.4]{E(P).png}

